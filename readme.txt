English
-------

see readme.eng.txt

Для чего это нужно
------------------

На нас надвигается эпоха, когда повсеместно могут начать блокировать уже не отдельные IP адреса или домены, а протоколы.
Одним из способов возможного преодоления сигнатурного анализа на DPI является модификация протокола.
Лучший способ - модифицировать сам софт, работающий с этими протоколами. Но не всегда это бывает просто или возможно.
Для TCP существует obfsproxy. Однако, в случае VPN - по TCP работают только не очень быстрые решения (openvpn).

Что же делать в случае udp ?
Если оба endpoint-а находятся на белом IP, то можно как следует поизвращаться прямо на уровне IP и дальше.
Например, если у вас VPS, а дома роутер на openwrt, вы имеете прямой IP от провайдера, то можно применить эту технику.
Если один endpoint находится за NAT, то можно как следует поизвращаться на уровне udp или tcp,
не трогая IP и начало заголовков tcp/udp.

Схема выглядит следующим образом :
 peer 1 <=> обфускатор/деобфускатор IP <=> сеть <=> обфускатор/деобфускатор IP <=> peer 2

Чтобы пакет был доставлен от peer 1 до peer 2, оба имеющих белые IP, достаточно лишь иметь корректные IP заголовки.
Можно выставить любой protocol number, проксорить или зашифровать IP payload, включая tcp/udp хедеры.
DPI от такого может выпасть в осадок. Оно не будет понимать с чем имеет дело.
Какие-то нестандартные IP протоколы с непонятно каким наполнением.
Конечно, DPI может обрезать весь мусор (по его мнению), но совсем не обязательно будет это делать.
Обычная программа не может сгененировать подобного типа "мусор", если только не использует raw sockets.
Значит разработчики DPI вряд ли поставят себе целью ловить рыбку в "мутной воде", если только какое-то решение
по обходу DPI на базе этой техники не станет достаточно популярным или белосписочность фильтров не достигнет высокого уровня.


ipobfs
------

Обработчик очереди NFQUEUE, обфускатор/деобфускатор пакетов.

 --daemon			; демонизировать прогу
 --pidfile=<file>		; сохранить PID в файл
 --user=<username>		; менять uid процесса
 --uid=uid[:gid]		; менять uid процесса
 --qnum=200			; номер очереди
 --debug                        ; вывод отладочной информации
 --ipproto-xor=0..255|0x00..0xFF; проксорить protocol number с указанным значением
 --data-xor=0xDEADBEAF          ; проксорить содержимое IP payload указанным 32-битным HEX значением
 --data-xor-offset=<position>   ; начинать проксоривание со смещения position после IP хедера
 --data-xor-len=<bytes>         ; ксорить не более указанного количества байтов, начиная с позиции data-xor-offset
 --csum=none|fix|valid 		; режим работы с чексуммой транспортных хедеров tcp и udp

Операция xor симметрична, поэтому для обфускатора и деобфускатора задаются одни и те же параметры.
На каждой стороне запускается по одному экземпляру программы.

Придется немного повозиться с iptables. Отфильтровать исходящий пакет просто, потому что он
идет "в открытую". На входящий пакет придется писать фильтры через u32.
Номер протокола ("-p") в фильтре - это результат xor исходного протокола с ipproto-xor.

server ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0&0xFFFF=16" -j NFQUEUE --queue-num 300 --queue-bypass
iptables -t mangle -I POSTROUTING -o eth0 -p udp --sport 16  -j NFQUEUE --queue-num 300 --queue-bypass

client ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0>>16&0xFFFF=16" -j NFQUEUE --queue-num 300 --queue-bypass
iptables -t mangle -I POSTROUTING -o eth0 -p udp --dport 16  -j NFQUEUE --queue-num 300 --queue-bypass

ipobfs --qnum=300 --ipproto-xor=128 --data-xor=0x458A2ECD --data-xor-offset=4 --data-xor-len=44

Почему data-xor-offset=4 : у tcp и udp в начале загловка идут номера порта источника и приемника, по 2 байта на каждый.
Чтобы проще было писать u32 не трогаем номера портов. Можно и тронуть, но тогда придется вычислить что же получится
после проксоривания и писать в u32 уже эти значения.
Почему data-xor-len=44 : пример приведен для wireguard. 44 байта достаточно, чтобы заксорить udp header и все заголовки wireguard.
Дальше идут шифрованные данные wireguard, их ксорить смысла нет.

Можно даже превратить udp в "tcp мусор" при ipproto-xor=23. Согласно заголовку ip это tcp, но на месте tcp хедера мусор.
Такого рода пакеты с одной стороны могут нарваться на middle-боксы, и на них сойдет с ума conntrack.
С другой стороны это может оказаться даже хорошо.

С ipv6 есть нюансы. В ipv6 нет понятия номера протокола. Зато есть понятие "next header".
Как и в ipv4 можно туда записать все что угодно. Но на практике это может вызвать лавину ICMPv6 собщений "Type 4 - Parameter Problem".
Чтобы этого избежать, надо приводить протокол к значению 59. Оно означает "no Next Header".
Проксорьте 59 с номером исходного протокола, получите параметр для "ipproto-xor".
Например, для udp номер протокола - 17. ipproto-xor=17^59=42
Для tcp номер протокола - 6. ipproto-xor=6^59=61

server ipv6 tcp:12345 :
ip6tables -t mangle -I PREROUTING -i eth0 -p 59 -m u32 --u32 "40&0xFFFF=12345" -j NFQUEUE --queue-num 300 --queue-bypass
ip6tables -t mangle -I POSTROUTING -o eth0 -p tcp --sport 12345 -j NFQUEUE --queue-num 300 --queue-bypass

client ipv6 tcp:12345 :
ip6tables -t mangle -I PREROUTING -i eth0 -p 59 -m u32 --u32 "38&0xFFFF=12345" -j NFQUEUE --queue-num 300 --queue-bypass
ip6tables -t mangle -I POSTROUTING -o eth0 -p tcp --dport 12345 -j NFQUEUE --queue-num 300 --queue-bypass

ipobfs --qnum=300 --ipproto-xor=61 --data-xor=0x458A2ECD --data-xor-offset=4


ЧЕКСУММЫ :
Работа с чексуммами начинается, когда принимается или отсылается tcp/udp пакет (до обфускации/деобфускации).
Если принят пакет с ip protocol, отличным от tcp или udp, с чексуммой ничего не делается, даже если после
деобфускации пакет превращается в tcp или udp. Предполагается, что если по сети пакет передается с измененным ip протоколом,
то никто не будет искать в нем tcp или udp header, чтобы поправить чексумму.
--csum=none - не трогать чексуммы вообще. если после деобфускации чексумма окажется инвалидной, система отбросит пакет.
--csum=fix - режим игнорирования чексуммы. технически невозможно в NFQUEUE отключить проверку чексумм, потому чексумма
 приводится к валидному значению, чтобы система не отбросила пакет. работает только для входящих пакетов.
--csum=valid - приводить чексумму к валидному состоянию для всех пакетов - входящих и исходящих. режим полезен при работе через cgnat
Пересчет чексумм увеличивает нагрузку на cpu.
См. так же раздел "пробитие NAT".


НЕДОСТАТКИ :
Каждый пакет будет забрасываться в nfqueue, потому скорость значительно снизится. В 2-3 раза.
Если сравнивать wireguard+ipobfs с openvpn на soho роутере, то openvpn все равно окажется медленней.


ipobfs_mod
-----------

То же самое, что и ipobfs, только выполнен в виде модуля ядра linux. Дает просадку производительности всего в пределах 20%.
По логике функционирования дублирует ipobfs и совместим с ним.
Значит можно на 1 хосте включить ipobfs, на другом ipobfs_mod, и они вместе будут работать.
Команды iptables те же самые, только вместо направления на очередь NFQEUEUE выставляется бит в fmwark.
ipobfs_mod реагирует на выставленные биты и производит обработку пакетов.

Настройки передаются через параметры модуля ядра, задаваемые командой insmod.

server ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0&0xFFFF=16" -j MARK --set-xmark 0x100/0x100
iptables -t mangle -I POSTROUTING -o eth0 -p udp --sport 16 -j MARK --set-xmark 0x100/0x100

client ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0>>16&0xFFFF=16" -j MARK --set-xmark 0x100/0x100
iptables -t mangle -I POSTROUTING -o eth0 -p udp --dport 16 -j MARK --set-xmark 0x100/0x100

rmmod ipobfs
insmod /lib/modules/`uname -r`/extra/ipobfs.ko  mark=0x100 ipp_xor=128 data_xor=0x458A2ECD data_xor_offset=4 data_xor_len=44

Модуль поддерживает до 10 профилей. Настройки параметров для каждого профиля идут через запятую.
Например, следующая команда объединит функции 2 обработчиков NFQUEUE из предыдущих примеров :
insmod /lib/modules/`uname -r`/extra/ipobfs.ko  mark=0x100,0x200 ipp_xor=128,61 data_xor=0x458A2ECD,0x458A2ECD data_xor_offset=4,4 data_xor_len=44,0
Возможно применение разных профилей для исходящих и входящих пакетов. Так вы еще больше запутаете DPI, уменьшив корреляцию in/out потоков.

По умолчанию модуль устанавливает хук на входящие пакеты с приоритетом mangle+1, чтобы к моменту вызова была выполнена таблица mangle.
Если на вход поступают нестандартные протоколы, все в порядке. Но если идут пакеты с транспортным протоколом, в которых предусмотрена
чексумма, такие как tcp или udp, то модифицированные пакеты с инвалидной чексуммой до хука mangle+1 не доходят. Модуль их не получает.
Чтобы решить эту проблему, укажите параметр pre=raw и делайте : iptables -t raw -I PREROUTING ...
Исходящие пакеты можно обрабатывать в обычном порядке через mangle.

Модуль отключает проверку и подсчет чексумм на уровне ОС для обрабатываемых пакетов, в некоторых случаях пересчитывая
чексуммы tcp и udp самостоятельно.
Если параметр csum=none, модуль не считает суммы вообще. Сумма исходящего пакета может оказаться невалидной.
При csum=fix модуль считает сумму исходяшего пакета до модификации пейлоада, тем самым повторяя функции ОС
или offload-а на сетевой карточке, чтобы они не сделали это на уже модифицированном пейлоаде и не испортили 2 байта данных,
а передаваемый пакет после деобфускации содержал корректную чексумму.
Если csum=valid, пересчет чексуммы производится после модификации пейлоада, как для исходящих, так и для входящих пакетов.
Тем самым обеспечивается видимость передачи пакетов с валидной чексуммой. Коррекция чексуммы на входящем пакете необходима,
если устройство с ipobfs не является получателем пакета, а выполняет функцию роутера (forward). Чтобы на выходном интерфейсе был валидный пакет.
Обычный получатель не примет пакеты с инвалидной чексуммой.

Параметр debug=1 включает вывод отладочной информации. Вы увидите что делается с каждым обрабатываемым пакетом в dmesg.
Его стоит применять только для отладки. При большом количестве пакетов система сильно затормозится из-за избыточного вывода в dmesg.

Посмотреть и изменить параметры ipobfs можно без перезагрузки модуля : /sys/module/ipobfs/parameters

СБОРКА МОДУЛЯ ЯДРА на традиционной linux системе :
установить заголовки ядра. для debian :
sudo apt-get install linux-headers.....
cd ipobfs_mod
make
sudo make install

openwrt
-------

На системе linux скачайте и распакуйте SDK от вашей версии прошивки для вашего девайса.
Версия SDK должна в точности соответствовать версии прошивки, иначе вы не соберете подходящий модуль ядра.
Если вы собирали прошивку самостоятельно, вместо SDK можно и нужно использовать этот buildroot.
scripts/feeds update -a
scripts/feeds install -a
Скопируйте openwrt/* в SDK, сохраняя структуру директорий.
В packages/ipobfs, там где Makefile, поместите каталоги ipobfs и ipobfs_mod с исходниками.
Из корня SDK : make package/ipobfs/compile V=99
Должны получиться 2 ipk : bin/packages/..../ipobfs..ipk и bin/targets/..../kmod-ipobfs..ipk
Переносите их на девайс, устанавливаете через "opkg install ...ipk". Устанавливать можно только то, что вам нужно : ipobfs или kmod-ipobfs.


Пробитие NAT
------------

В общем случае можно утверждать, что NAT способны пропускать лишь трафик tcp и udp.
+ некоторые NAT еще содержат хелперы для пропуска особых протоколов (GRE). Но не все и не на всех устройствах.
Поэтому ipproto-xor применять нельзя.

Рассмотрим NAT на базе linux (почти все домашние роутеры) без хелперов.
Как показывает исследование, для него важны поля транспортного хедера, содержащие длину пейлоада и флаги.
Поэтому, минимальный xor-data-offset для tcp - 14 , для udp - 6. Иначе пакет вовсе не пройдет NAT.
Linux NAT не проверяет чексумму в транспортном хедере, ему не важны tcp options.
Любой NAT обязательно будет следить за флагами tcp, ведь по ним conntrack определяет начало установки соединения.
Без conntrack не работает ни один NAT. Смещение флагов в tcp header - 13.

Все без исключения NAT будут исправлять 2-байтовую чексумму в tcp (смещение 18) и udp (смещение 6),
поскольку она считается с учетом ip источника и назначения. NAT меняет ip источника при отсылке, при невозможности
сохранить исходный source port меняется и он. Для экономии ресурсов полный пересчет суммы обычно не производится.
За основу берется исходная сумма, к ней добавляется разница между исходными и измененными значениями.
К получателю приходит пакет с инвалидной суммой, далее он деобфусцируется средствами ipobfs и сумма становится валидной,
если при обфускации не была затронута исходная сумма, то есть data-xor-offset>=20 для tcp и data-xor-offset>=8 для udp.
Обфускатор работает по xor, checksum считается сложением, поэтому они несовместимы.
ipobfs по умолчанию не пересчитывает чексуммы транспортных хедеров, поэтому если на принимающем конце используется он, то
data-xor-offset необходимо делать таким, чтобы чексумма не затрагивалась, иначе пакет будет отброшен системой после деобфускации.
альтернатива - использовать опцию --csum=fix
ipobfs_mod отключает проверку чексумм, поэтому при его использовании этой проблемы нет. поведение по умолчанию аналогично --csum=fix

Большинство роутеров выполняют mss fix ( -j TCPMSS --clamp-mss-to-pmtu  или  -j TCPMSS --set-mss ).
mss находится в опциях tcp header. Windows и linux шлют mss первой опцией. Сама опция занимает 4 байта.
Выходит, минимальный xor-data-offset для tcp поднимается до 24, чтобы не трогать mss, который попортит роутер.

ИТОГ :
 tcp : data-xor-offset>=24
 udp : data-xor-offset>=8

Не все NAT будут пропускать невалидные пакеты. Тесты на некоторых провайдерах за NAT показывают, что пакеты с невалидной
чексуммой не доходят вообще.
Некоторые роутеры делают аппаратный NAT через offload. Пропускают ли такие NAT невалидные пакеты пока неизвестно.
Но даже если и нет, то аппаратный NAT обычно отключается в настройках прошивки, тем самым оставляя обычный linux NAT.

Если NAT не пропускает пакеты с инвалидной чексуммой, используйте настройку --csum=valid.
С точки зрения нагрузки на cpu предпочительней будет не использовать режим --csum=valid, если NAT пропускает пакеты с инвалидной чексуммой.

Есть информация, что некоторые мобильные операторы производят терминацию tcp на своих серверах для последующего
проксирования к точке исходного назначения. В этом случае любая модификация tcp не на уровне потока данных обречена на провал.
Терминирующий middlebox отвергнет пакеты с испорченным заголовком или неверной чексуммой.
Исходящее соединение от middlebox не будет повторять такое же разбиение на пакеты, как исходное соединение.
Пользуйтесь obfsproxy.

На нас надвигается эпоха, когда повсеместно могут начать блокировать уже не отдельные IP адреса или домены, а протоколы.
Одним из способов возможного преодоления сигнатурного анализа на DPI является модификация протокола.
Лучший способ - модифицировать сам софт, работающий с этими протоколами. Но не всегда это бывает просто или возможно.
Для TCP существует obfsproxy. Однако, в случае VPN - по TCP работают только не очень быстрые решения (openvpn).

Что же делать в случае udp ? Или если закрыты порты, протоколы секут по статистическим характеристикам ?
Если оба endpoint-а находятся на белом IP, то можно как следует поизвращаться прямо на уровне IP.
Например, если у вас VPS, а дома роутер на openwrt, вы имеете прямой IP от провайдера, то можно применить эту технику.

Схема выглядит следующим образом :
 peer 1 <=> обфускатор/деобфускатор IP <=> сеть <=> обфускатор/деобфускатор IP <=> peer 2

Чтобы пакет был доставлен от peer 1 до peer 2, оба имеющих белые IP, достаточно лишь иметь корректные IP заголовки.
Можно выставить любой protocol number, проксорить или зашифровать IP payload, включая tcp/udp хедеры.
DPI от такого может выпасть в осадок. Оно не будет понимать с чем имеет дело.
Какие-то нестандартные IP протоколы с непонятно каким наполнением.
Конечно, DPI может обрезать весь мусор (по его мнению), но совсем не обязательно будет это делать.
Обычная программа не может сгененировать подобного типа "мусор", если только не использует raw sockets.
Значит разработчики DPI вряд ли поставят себе целью ловить рыбку в "мутной воде", если только какое-то решение
по обходу DPI на базе этой техники не станет достаточно популярным или белосписочность фильтров не достигнет высокого уровня.


ipobfs
------

Обработчик очереди NFQUEUE, обфускатор/деобфускатор пакетов.

 --daemon			; демонизировать прогу
 --pidfile=<file>		; сохранить PID в файл
 --user=<username>		; менять uid процесса
 --uid=uid[:gid]		; менять uid процесса
 --qnum=200			; номер очереди
 --debug                        ; вывод отладочной информации
 --ipproto-xor=<0..255>         ; проксорить protocol number с указанным значением
 --data-xor=0xDEADBEAF          ; проксорить содержимое IP payload указанным 32-битным HEX значением
 --data-xor-offset=<position>   ; начинать проксоривание со смещения position после IP хедера

Операция xor симметрична, поэтому для обфускатора и деобфускатора задаются одни и те же параметры.
На каждой стороне запускается по одному экземпляру программы.

Придется немного повозиться с iptables. Отфильтровать исходящий пакет просто, потому что он
идет "в открытую". На входящий пакет придется писать фильтры через u32.
Номер протокола ("-p") в фильтре - это результат xor исходного протокола с ipproto-xor.

server ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0&0xFFFF=16" -j NFQUEUE --queue-num 300 --queue-bypass
iptables -t mangle -I POSTROUTING -o eth0 -p udp --sport 16  -j NFQUEUE --queue-num 300 --queue-bypass

client ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0>>16&0xFFFF=16" -j NFQUEUE --queue-num 300 --queue-bypass
iptables -t mangle -I POSTROUTING -o eth0 -p udp --dport 16  -j NFQUEUE --queue-num 300 --queue-bypass

ipobfs --qnum=300 --ipproto-xor=128 --data-xor=0x458A2ECD --data-xor-offset=4

Почему data-xor-offset=4 : у tcp и udp в начале загловка идут номера порта источника и приемника, по 2 байта на каждый.
Чтобы проще было писать u32 не трогаем номера портов. Можно и тронуть, но тогда придется вычислить что же получится
после проксоривания и писать в u32 уже эти значения.

Можно даже превратить udp в "tcp мусор" при ipproto-xor=23. Согласно заголовку ip это tcp, но на месте tcp хедера мусор.
Такого рода пакеты с одной стороны могут нарваться на middle-боксы, и на них сойдет с ума conntrack.
С другой стороны это может оказаться даже хорошо.

С ipv6 есть нюансы. В ipv6 нет понятия номера протокола. Зато есть понятие "next header".
Как и в ipv4 можно туда записать все что угодно. Но на практике это может вызвать лавину ICMPv6 собщений "Type 4 - Parameter Problem".
Чтобы этого избежать, надо приводить протокол к значению 59. Оно означает "no Next Header".
Проксорьте 59 с номером исходного протокола, получите параметр для "ipproto-xor".
Например, для udp номер протокола - 17. ipproto-xor=17^59=42
Для tcp номер протокола - 6. ipproto-xor=6^59=61

server ipv6 tcp:12345 :
ip6tables -t mangle -I PREROUTING -i eth0 -p 59 -m u32 --u32 "40&0xFFFF=12345" -j NFQUEUE --queue-num 300 --queue-bypass
ip6tables -t mangle -I POSTROUTING -o eth0 -p tcp --sport 12345 -j NFQUEUE --queue-num 300 --queue-bypass

client ipv6 tcp:12345 :
ip6tables -t mangle -I PREROUTING -i eth0 -p 59 -m u32 --u32 "38&0xFFFF=12345" -j NFQUEUE --queue-num 300 --queue-bypass
ip6tables -t mangle -I POSTROUTING -o eth0 -p tcp --dport 12345 -j NFQUEUE --queue-num 300 --queue-bypass

ipobfs --qnum=300 --ipproto-xor=61 --data-xor=0x458A2ECD --data-xor-offset=4


Недостатки
----------

Каждый пакет будет забрасываться в nfqueue, потому скорость значительно снизится. В 2-3 раза.
Если сравнивать wireguard+ipobfs с openvpn на soho роутере, то openvpn все равно окажется медленней.

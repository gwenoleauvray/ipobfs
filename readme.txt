На нас надвигается эпоха, когда повсеместно могут начать блокировать уже не отдельные IP адреса или домены, а протоколы.
Одним из способов возможного преодоления сигнатурного анализа на DPI является модификация протокола.
Лучший способ - модифицировать сам софт, работающий с этими протоколами. Но не всегда это бывает просто или возможно.
Для TCP существует obfsproxy. Однако, в случае VPN - по TCP работают только не очень быстрые решения (openvpn).

Что же делать в случае udp ?
Если оба endpoint-а находятся на белом IP, то можно как следует поизвращаться прямо на уровне IP и дальше.
Например, если у вас VPS, а дома роутер на openwrt, вы имеете прямой IP от провайдера, то можно применить эту технику.
Если один endpoint находится за NAT, то можно как следует поизвращаться на уровне udp или tcp,
не трогая IP и начало заголовков tcp/udp.

Схема выглядит следующим образом :
 peer 1 <=> обфускатор/деобфускатор IP <=> сеть <=> обфускатор/деобфускатор IP <=> peer 2

Чтобы пакет был доставлен от peer 1 до peer 2, оба имеющих белые IP, достаточно лишь иметь корректные IP заголовки.
Можно выставить любой protocol number, проксорить или зашифровать IP payload, включая tcp/udp хедеры.
DPI от такого может выпасть в осадок. Оно не будет понимать с чем имеет дело.
Какие-то нестандартные IP протоколы с непонятно каким наполнением.
Конечно, DPI может обрезать весь мусор (по его мнению), но совсем не обязательно будет это делать.
Обычная программа не может сгененировать подобного типа "мусор", если только не использует raw sockets.
Значит разработчики DPI вряд ли поставят себе целью ловить рыбку в "мутной воде", если только какое-то решение
по обходу DPI на базе этой техники не станет достаточно популярным или белосписочность фильтров не достигнет высокого уровня.


ipobfs
------

Обработчик очереди NFQUEUE, обфускатор/деобфускатор пакетов.

 --daemon			; демонизировать прогу
 --pidfile=<file>		; сохранить PID в файл
 --user=<username>		; менять uid процесса
 --uid=uid[:gid]		; менять uid процесса
 --qnum=200			; номер очереди
 --debug                        ; вывод отладочной информации
 --ipproto-xor=0..255|0x00..0xFF; проксорить protocol number с указанным значением
 --data-xor=0xDEADBEAF          ; проксорить содержимое IP payload указанным 32-битным HEX значением
 --data-xor-offset=<position>   ; начинать проксоривание со смещения position после IP хедера
 --data-xor-len=<bytes>         ; ксорить не более указанного количества байтов, начиная с позиции data-xor-offset

Операция xor симметрична, поэтому для обфускатора и деобфускатора задаются одни и те же параметры.
На каждой стороне запускается по одному экземпляру программы.

Придется немного повозиться с iptables. Отфильтровать исходящий пакет просто, потому что он
идет "в открытую". На входящий пакет придется писать фильтры через u32.
Номер протокола ("-p") в фильтре - это результат xor исходного протокола с ipproto-xor.

server ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0&0xFFFF=16" -j NFQUEUE --queue-num 300 --queue-bypass
iptables -t mangle -I POSTROUTING -o eth0 -p udp --sport 16  -j NFQUEUE --queue-num 300 --queue-bypass

client ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0>>16&0xFFFF=16" -j NFQUEUE --queue-num 300 --queue-bypass
iptables -t mangle -I POSTROUTING -o eth0 -p udp --dport 16  -j NFQUEUE --queue-num 300 --queue-bypass

ipobfs --qnum=300 --ipproto-xor=128 --data-xor=0x458A2ECD --data-xor-offset=4 --data-xor-len=44

Почему data-xor-offset=4 : у tcp и udp в начале загловка идут номера порта источника и приемника, по 2 байта на каждый.
Чтобы проще было писать u32 не трогаем номера портов. Можно и тронуть, но тогда придется вычислить что же получится
после проксоривания и писать в u32 уже эти значения.
Почему data-xor-len=44 : пример приведен для wireguard. 44 байта достаточно, чтобы заксорить udp header и все заголовки wireguard.
Дальше идут шифрованные данные wireguard, их ксорить смысла нет.

Можно даже превратить udp в "tcp мусор" при ipproto-xor=23. Согласно заголовку ip это tcp, но на месте tcp хедера мусор.
Такого рода пакеты с одной стороны могут нарваться на middle-боксы, и на них сойдет с ума conntrack.
С другой стороны это может оказаться даже хорошо.

С ipv6 есть нюансы. В ipv6 нет понятия номера протокола. Зато есть понятие "next header".
Как и в ipv4 можно туда записать все что угодно. Но на практике это может вызвать лавину ICMPv6 собщений "Type 4 - Parameter Problem".
Чтобы этого избежать, надо приводить протокол к значению 59. Оно означает "no Next Header".
Проксорьте 59 с номером исходного протокола, получите параметр для "ipproto-xor".
Например, для udp номер протокола - 17. ipproto-xor=17^59=42
Для tcp номер протокола - 6. ipproto-xor=6^59=61

server ipv6 tcp:12345 :
ip6tables -t mangle -I PREROUTING -i eth0 -p 59 -m u32 --u32 "40&0xFFFF=12345" -j NFQUEUE --queue-num 300 --queue-bypass
ip6tables -t mangle -I POSTROUTING -o eth0 -p tcp --sport 12345 -j NFQUEUE --queue-num 300 --queue-bypass

client ipv6 tcp:12345 :
ip6tables -t mangle -I PREROUTING -i eth0 -p 59 -m u32 --u32 "38&0xFFFF=12345" -j NFQUEUE --queue-num 300 --queue-bypass
ip6tables -t mangle -I POSTROUTING -o eth0 -p tcp --dport 12345 -j NFQUEUE --queue-num 300 --queue-bypass

ipobfs --qnum=300 --ipproto-xor=61 --data-xor=0x458A2ECD --data-xor-offset=4

НЕДОСТАТКИ :
Каждый пакет будет забрасываться в nfqueue, потому скорость значительно снизится. В 2-3 раза.
Если сравнивать wireguard+ipobfs с openvpn на soho роутере, то openvpn все равно окажется медленней.


ipobfs_mod
-----------

То же самое, что и ipobfs, только выполнен в виде модуля ядра linux. Дает просадку производительности всего в пределах 20%.
По логике функционирования полностью дублирует ipobfs и совместим с ним. Значит можно на 1 хосте включить ipobfs, на другом ipobfs_mod, и они вместе будут работать.
Команды iptables те же самые, только вместо направления на очередь NFQEUEUE выставляется бит в fmwark.
ipobfs_mod реагирует на выставленные биты и производит обработку пакетов.

Настройки передаются через параметры модуля ядра, задаваемые командой insmod.

server ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0&0xFFFF=16" -j MARK --set-xmark 0x100/0x100
iptables -t mangle -I POSTROUTING -o eth0 -p udp --sport 16 -j MARK --set-xmark 0x100/0x100

client ipv4 udp:16 :
iptables -t mangle -I PREROUTING -i eth0 -p 145 -m u32 --u32 "0>>22&0x3C@0>>16&0xFFFF=16" -j MARK --set-xmark 0x100/0x100
iptables -t mangle -I POSTROUTING -o eth0 -p udp --dport 16 -j MARK --set-xmark 0x100/0x100

rmmod ipobfs
insmod /lib/modules/`uname -r`/extra/ipobfs.ko  mark=0x100 ipp_xor=128 data_xor=0x458A2ECD data_xor_offset=4 data_xor_len=44

Модуль поддерживает до 10 профилей. Настройки параметров для каждого профиля идут через запятую.
Например, следующая команда объединит функции 2 обработчиков NFQUEUE из предыдущих примеров :
insmod /lib/modules/`uname -r`/extra/ipobfs.ko  mark=0x100,0x200 ipp_xor=128,61 data_xor=0x458A2ECD,0x458A2ECD data_xor_offset=4,4 data_xor_len=44,0
Возможно применение разных профилей для исходящих и входящих пакетов. Так вы еще больше запутаете DPI, уменьшив корреляцию in/out потоков.

По умолчанию модуль устанавливает хук на входящие пакеты с приоритетом mangle+1, чтобы к моменту вызова была выполнена таблица mangle.
Если на вход поступают нестандартные протоколы, все в порядке. Но если идут пакеты с транспортным протоколом, в которых предусмотрена
чексумма, такие как tcp или udp, то модифицированные пакеты с инвалидной чексуммой до хука mangle+1 не доходят. Модуль их не получает.
Чтобы решить эту проблему, укажите параметр pre=raw и делайте : iptables -t raw -I PREROUTING ...
Исходящие пакеты можно обрабатывать в обычном порядке через mangle.

Модуль пересчитывает чексуммы tcp и udp.
Если параметр validcsum=0, модуль берет на себя пересчет чексуммы на исходящих пакетах до модификации пейлоада, тем самым повторяя функции ОС
или offload-а на сетевой карточке, чтобы они не сделали это на уже модифицированном пейлоаде и не испортили 2 байта данных,
а передаваемый пакет после деобфускации содержал корректную чексумму.
Если validcsum=1, пересчет чексуммы производится после модификации пейлоада, как для исходящих, так и для входящих пакетов.
Тем самым обеспечивается видимость передачи пакетов с валидной чексуммой. Коррекция чексуммы на входящем пакете необходима,
если устройство с ipobfs не является получателем пакета, а выполняет функцию роутера (forward). Чтобы на выходном интерфейсе был валидный пакет.
Обычный получатель не примет пакеты с инвалидной чексуммой.

Параметр debug=1 включает вывод отладочной информации. Вы увидите что делается с каждым обрабатываемым пакетом в dmesg.
Его стоит применять только для отладки. При большом количестве пакетов система сильно затормозится из-за избыточного вывода в dmesg.

Посмотреть и изменить параметры ipobfs можно без перезагрузки модуля : /sys/module/ipobfs/parameters

СБОРКА МОДУЛЯ ЯДРА на традиционной linux системе :
установить заголовки ядра. для debian :
sudo apt-get install linux-headers.....
cd ipobfs_mod
make
sudo make install

openwrt
-------

На системе linux скачайте и распакуйте SDK от вашей версии прошивки для вашего девайса.
Версия SDK должна в точности соответствовать версии прошивки, иначе вы не соберете подходящий модуль ядра.
Если вы собирали прошивку самостоятельно, вместо SDK можно и нужно использовать этот buildroot.
scripts/feeds update -a
scripts/feeds install -a
Скопируйте openwrt/* в SDK, сохраняя структуру директорий.
В packages/ipobfs, там где Makefile, поместите каталоги ipobfs и ipobfs_mod с исходниками.
Из корня SDK : make package/ipobfs/compile V=99
Должны получиться 2 ipk : bin/packages/..../ipobfs..ipk и bin/targets/..../kmod-ipobfs..ipk
Переносите их на девайс, устанавливаете через "opkg install ...ipk". Устанавливать можно только то, что вам нужно : ipobfs или kmod-ipobfs.


Пробитие NAT
------------

В общем случае можно утверждать, что NAT способны пропускать лишь трафик tcp и udp.
+ некоторые NAT еще содержат хелперы для пропуска особых протоколов (GRE). Но не все и не на всех устройствах.
Поэтому ipproto-xor применять нельзя.

Рассмотрим NAT на базе linux (почти все домашние роутеры) без хелперов.
Как плказывает исследование, для него важны поля транспортного хедера, содержащие длину пейлоада и флаги.
Поэтому, минимальный xor-data-offset для tcp - 14 , для udp - 6.
Linux NAT не проверяет чексумму в транспортном хедере, ему не важны tcp options.
Любой NAT обязательно будет следить за флагами tcp, ведь по ним conntrack определяет начало установки соединения.
Без conntrack не работает ни один NAT. Смещение флагов в tcp header - 13.

Есть информация, что некоторые мобильные операторы производят терминацию tcp на своих серверах для последующего
проксирования к точке исходного назначения. В этом случае любая модификация tcp не на уровне потока данных обречена на провал.
Терминирующий middlebox отвергнет пакеты с испорченным заголовком или неверной чексуммой.
Исходящее соединение от middlebox не будет повторять такое же разбиение на пакеты, как исходное соединение.
Пользуйтесь obfsproxy.
